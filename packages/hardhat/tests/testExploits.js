const convert = (amount, decimals) => ethers.utils.parseUnits(amount, decimals);
const divDec = (amount, decimals = 18) => amount / 10 ** decimals;
const divDec6 = (amount) => amount / 10 ** 6;
const { expect } = require("chai");
const { ethers, network } = require("hardhat");

const AddressZero = "0x0000000000000000000000000000000000000000";
const AddressDead = "0x000000000000000000000000000000000000dEaD";

async function getAuctionData(content, tokenId) {
  return {
    epochId: await content.idToEpochId(tokenId),
    initPrice: await content.idToInitPrice(tokenId),
    startTime: await content.idToStartTime(tokenId)
  };
}

let owner, protocol, launcher, attacker, user1, user2;
let usdc, donut, core, multicall;
let content, minter, rewarder, auction, unit, lpToken;
let unitFactory, contentFactory, minterFactory, rewarderFactory, auctionFactory;
let uniswapFactory, uniswapRouter;

const WEEK = 7 * 24 * 60 * 60;
const DAY = 24 * 60 * 60;

describe("Security & Exploit Tests", function () {
  before("Initial set up", async function () {
    await network.provider.send("hardhat_reset");
    console.log("Begin Initialization");

    [owner, protocol, launcher, attacker, user1, user2] = await ethers.getSigners();

    // Deploy USDC (6 decimals) as quote token
    const usdcArtifact = await ethers.getContractFactory("MockUSDC");
    usdc = await usdcArtifact.deploy();
    console.log("- USDC Initialized");

    // Deploy mock DONUT token
    const donutArtifact = await ethers.getContractFactory("MockWETH");
    donut = await donutArtifact.deploy();
    console.log("- DONUT Initialized");

    // Deploy mock Uniswap V2 Factory and Router
    const mockUniswapFactoryArtifact = await ethers.getContractFactory("MockUniswapV2Factory");
    uniswapFactory = await mockUniswapFactoryArtifact.deploy();
    console.log("- Uniswap V2 Factory Initialized");

    const mockUniswapRouterArtifact = await ethers.getContractFactory("MockUniswapV2Router");
    uniswapRouter = await mockUniswapRouterArtifact.deploy(uniswapFactory.address);
    console.log("- Uniswap V2 Router Initialized");

    // Deploy factories
    const unitFactoryArtifact = await ethers.getContractFactory("UnitFactory");
    unitFactory = await unitFactoryArtifact.deploy();
    console.log("- UnitFactory Initialized");

    const contentFactoryArtifact = await ethers.getContractFactory("ContentFactory");
    contentFactory = await contentFactoryArtifact.deploy();
    console.log("- ContentFactory Initialized");

    const minterFactoryArtifact = await ethers.getContractFactory("MinterFactory");
    minterFactory = await minterFactoryArtifact.deploy();
    console.log("- MinterFactory Initialized");

    const rewarderFactoryArtifact = await ethers.getContractFactory("RewarderFactory");
    rewarderFactory = await rewarderFactoryArtifact.deploy();
    console.log("- RewarderFactory Initialized");

    const auctionFactoryArtifact = await ethers.getContractFactory("AuctionFactory");
    auctionFactory = await auctionFactoryArtifact.deploy();
    console.log("- AuctionFactory Initialized");

    // Deploy Core
    const coreArtifact = await ethers.getContractFactory("Core");
    core = await coreArtifact.deploy(
      usdc.address,
      donut.address,
      uniswapFactory.address,
      uniswapRouter.address,
      unitFactory.address,
      contentFactory.address,
      minterFactory.address,
      auctionFactory.address,
      rewarderFactory.address,
      protocol.address,
      convert("100", 18)
    );
    console.log("- Core Initialized");

    // Deploy Multicall
    const multicallArtifact = await ethers.getContractFactory("Multicall");
    multicall = await multicallArtifact.deploy(core.address, usdc.address, donut.address);
    console.log("- Multicall Initialized");

    // Mint DONUT to launcher and launch a content engine
    await donut.connect(launcher).deposit({ value: convert("10000", 18) });
    console.log("- DONUT minted to launcher");

    const launchParams = {
      launcher: launcher.address,
      tokenName: "Test Unit",
      tokenSymbol: "TUNIT",
      uri: "https://example.com/metadata",
      donutAmount: convert("500", 18),
      unitAmount: convert("1000000", 18),
      initialUps: convert("4", 18),
      tailUps: convert("0.01", 18),
      halvingPeriod: WEEK,
      contentMinInitPrice: convert("1", 6),
      contentIsModerated: false,
      auctionInitPrice: convert("1000", 6),
      auctionEpochPeriod: DAY,
      auctionPriceMultiplier: convert("1.5", 18),
      auctionMinInitPrice: convert("1", 6),
    };

    await donut.connect(launcher).approve(core.address, launchParams.donutAmount);
    const tx = await core.connect(launcher).launch(launchParams);
    const receipt = await tx.wait();

    const launchEvent = receipt.events.find((e) => e.event === "Core__Launched");
    content = await ethers.getContractAt("Content", launchEvent.args.content);
    unit = await ethers.getContractAt("Unit", launchEvent.args.unit);
    minter = await ethers.getContractAt("Minter", launchEvent.args.minter);
    rewarder = await ethers.getContractAt("Rewarder", launchEvent.args.rewarder);
    auction = await ethers.getContractAt("Auction", launchEvent.args.auction);
    lpToken = await ethers.getContractAt("IERC20", launchEvent.args.lpToken);

    console.log("- Content Engine launched");
    console.log("Initialization Complete\n");
  });

  describe("Content Contract Attacks", function () {
    describe("Transfer Circumvention", function () {
      it("Should block approve()", async function () {
        await content.connect(user1).create(user1.address, "ipfs://test");
        const tokenId = await content.nextTokenId();

        await expect(content.connect(user1).approve(attacker.address, tokenId)).to.be.revertedWith(
          "Content__TransferDisabled()"
        );
      });

      it("Should block setApprovalForAll()", async function () {
        await expect(
          content.connect(user1).setApprovalForAll(attacker.address, true)
        ).to.be.revertedWith("Content__TransferDisabled()");
      });

      it("Should block transferFrom()", async function () {
        const tokenId = await content.nextTokenId();
        await expect(
          content.connect(user1).transferFrom(user1.address, attacker.address, tokenId)
        ).to.be.revertedWith("Content__TransferDisabled()");
      });

      it("Should block safeTransferFrom()", async function () {
        const tokenId = await content.nextTokenId();
        await expect(
          content.connect(user1)["safeTransferFrom(address,address,uint256)"](user1.address, attacker.address, tokenId)
        ).to.be.revertedWith("Content__TransferDisabled()");
      });
    });

    describe("Front-running Protection", function () {
      it("Should protect against epoch ID front-running", async function () {
        // Create new content
        await content.connect(user1).create(user1.address, "ipfs://test-frontrun");
        const tokenId = await content.nextTokenId();

        const auctionData = await getAuctionData(content, tokenId);
        const price = await content.getPrice(tokenId);

        // User1 collects first
        await usdc.mint(user1.address, price);
        await usdc.connect(user1).approve(content.address, price);
        await content
          .connect(user1)
          .collect(user1.address, tokenId, auctionData.epochId, ethers.constants.MaxUint256, price);

        // Attacker tries to use old epochId
        await usdc.mint(attacker.address, convert("100", 6));
        await usdc.connect(attacker).approve(content.address, convert("100", 6));

        await expect(
          content
            .connect(attacker)
            .collect(attacker.address, tokenId, auctionData.epochId, ethers.constants.MaxUint256, convert("100", 6))
        ).to.be.revertedWith("Content__EpochIdMismatch()");
      });

      it("Should protect against deadline expiry", async function () {
        await content.connect(user1).create(user1.address, "ipfs://test-deadline");
        const tokenId = await content.nextTokenId();

        const auctionData = await getAuctionData(content, tokenId);
        const price = await content.getPrice(tokenId);

        await usdc.mint(attacker.address, price);
        await usdc.connect(attacker).approve(content.address, price);

        const block = await ethers.provider.getBlock("latest");
        const pastDeadline = block.timestamp - 1;

        await expect(
          content.connect(attacker).collect(attacker.address, tokenId, auctionData.epochId, pastDeadline, price)
        ).to.be.revertedWith("Content__Expired()");
      });

      it("Should protect against price slippage", async function () {
        await content.connect(user1).create(user1.address, "ipfs://test-slippage");
        const tokenId = await content.nextTokenId();

        const auctionData = await getAuctionData(content, tokenId);
        const price = await content.getPrice(tokenId);

        // Only test if price > 0
        if (price.gt(0)) {
          await usdc.mint(attacker.address, price);
          await usdc.connect(attacker).approve(content.address, price);

          // Set maxPrice to 0 to guarantee it fails
          const tooLowMaxPrice = 0;

          await expect(
            content
              .connect(attacker)
              .collect(attacker.address, tokenId, auctionData.epochId, ethers.constants.MaxUint256, tooLowMaxPrice)
          ).to.be.reverted;
        }
      });
    });
  });

  describe("Minter Contract Attacks", function () {
    describe("Unauthorized Minting", function () {
      it("Should only allow minter to mint Unit tokens", async function () {
        await expect(unit.connect(attacker).mint(attacker.address, convert("1000000", 18))).to.be.reverted;
      });

      it("Should prevent setting minter by non-owner", async function () {
        await expect(unit.connect(attacker).setMinter(attacker.address)).to.be.reverted;
      });
    });

    describe("Emission Manipulation", function () {
      it("Should not allow multiple emissions in same week", async function () {
        // First update
        await ethers.provider.send("evm_increaseTime", [WEEK]);
        await ethers.provider.send("evm_mine");
        await minter.updatePeriod();

        const periodAfterFirst = await minter.activePeriod();

        // Try to update again immediately
        await minter.updatePeriod();

        // Period should not change
        expect(await minter.activePeriod()).to.equal(periodAfterFirst);
      });
    });
  });

  describe("Rewarder Contract Attacks", function () {
    describe("Unauthorized Operations", function () {
      it("Should prevent direct deposit by non-Content", async function () {
        await expect(
          rewarder.connect(attacker).deposit(attacker.address, convert("1", 18))
        ).to.be.reverted;
      });

      it("Should prevent direct withdraw by non-Content", async function () {
        await expect(
          rewarder.connect(attacker).withdraw(attacker.address, convert("1", 18))
        ).to.be.reverted;
      });

      it("Should prevent adding rewards by non-Content", async function () {
        const mockToken = await (await ethers.getContractFactory("MockWETH")).deploy();

        await expect(rewarder.connect(attacker).addReward(mockToken.address)).to.be.reverted;
      });
    });

    describe("Reward Theft", function () {
      it("Should only transfer earned rewards to correct recipient", async function () {
        // User1 creates and collects content
        await content.connect(user1).create(user1.address, "ipfs://test-reward-theft");
        const tokenId = await content.nextTokenId();
        const price = await content.getPrice(tokenId);

        await usdc.mint(user1.address, price);
        await usdc.connect(user1).approve(content.address, price);
        const auctionData = await getAuctionData(content, tokenId);
        await content
          .connect(user1)
          .collect(user1.address, tokenId, auctionData.epochId, ethers.constants.MaxUint256, price);

        // Rewards already distributed via minter.updatePeriod() during init
        await ethers.provider.send("evm_increaseTime", [DAY]);
        await ethers.provider.send("evm_mine");

        // Attacker claims for user1 (this is allowed, but funds go to user1)
        const attackerBalanceBefore = await unit.balanceOf(attacker.address);
        const user1BalanceBefore = await unit.balanceOf(user1.address);

        await rewarder.connect(attacker).getReward(user1.address);

        const attackerBalanceAfter = await unit.balanceOf(attacker.address);
        const user1BalanceAfter = await unit.balanceOf(user1.address);

        // Attacker should receive nothing
        expect(attackerBalanceAfter).to.equal(attackerBalanceBefore);
        // User1 may receive rewards (if any were earned)
        expect(user1BalanceAfter).to.be.gte(user1BalanceBefore);
      });
    });
  });

  describe("Core Contract Attacks", function () {
    describe("Registry Manipulation", function () {
      it("Should only allow owner to set protocol fee address", async function () {
        await expect(
          core.connect(attacker).setProtocolFeeAddress(attacker.address)
        ).to.be.revertedWith("Ownable: caller is not the owner");
      });

      it("Should only allow owner to set min donut for launch", async function () {
        await expect(
          core.connect(attacker).setMinDonutForLaunch(convert("1", 18))
        ).to.be.revertedWith("Ownable: caller is not the owner");
      });
    });

    describe("Launch Parameter Validation", function () {
      it("Should reject launch with insufficient DONUT", async function () {
        await donut.connect(attacker).deposit({ value: convert("50", 18) });
        await donut.connect(attacker).approve(core.address, convert("50", 18));

        const launchParams = {
          launcher: attacker.address,
          tokenName: "Bad",
          tokenSymbol: "BAD",
          uri: "ipfs://bad",
          donutAmount: convert("50", 18), // Less than min
          unitAmount: convert("1000", 18),
          initialUps: convert("1", 18),
          tailUps: convert("0.01", 18),
          halvingPeriod: WEEK,
          contentMinInitPrice: convert("1", 6),
          contentIsModerated: false,
          auctionInitPrice: convert("1000", 6),
          auctionEpochPeriod: DAY,
          auctionPriceMultiplier: convert("1.5", 18),
          auctionMinInitPrice: convert("1", 6),
        };

        await expect(core.connect(attacker).launch(launchParams)).to.be.revertedWith(
          "Core__InsufficientDonut()"
        );
      });

      it("Should reject zero launcher address", async function () {
        await donut.connect(attacker).deposit({ value: convert("500", 18) });
        await donut.connect(attacker).approve(core.address, convert("500", 18));

        const launchParams = {
          launcher: AddressZero,
          tokenName: "Bad",
          tokenSymbol: "BAD",
          uri: "ipfs://bad",
          donutAmount: convert("500", 18),
          unitAmount: convert("1000", 18),
          initialUps: convert("1", 18),
          tailUps: convert("0.01", 18),
          halvingPeriod: WEEK,
          contentMinInitPrice: convert("1", 6),
          contentIsModerated: false,
          auctionInitPrice: convert("1000", 6),
          auctionEpochPeriod: DAY,
          auctionPriceMultiplier: convert("1.5", 18),
          auctionMinInitPrice: convert("1", 6),
        };

        await expect(core.connect(attacker).launch(launchParams)).to.be.revertedWith(
          "Core__InvalidLauncher()"
        );
      });
    });
  });

  describe("Access Control", function () {
    it("Content owner functions should be restricted", async function () {
      await expect(content.connect(attacker).setUri("ipfs://evil")).to.be.revertedWith(
        "Ownable: caller is not the owner"
      );

      await expect(content.connect(attacker).setTreasury(attacker.address)).to.be.revertedWith(
        "Ownable: caller is not the owner"
      );

      await expect(content.connect(attacker).setIsModerated(false)).to.be.revertedWith(
        "Ownable: caller is not the owner"
      );

      await expect(content.connect(attacker).setModerators([attacker.address], true)).to.be.revertedWith(
        "Ownable: caller is not the owner"
      );
    });
  });
});
